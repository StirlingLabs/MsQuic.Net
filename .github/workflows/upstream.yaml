name: Follow Upstream

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ '**', '!gh-pages', '!coverage' ]
    types: [ opened, reopened, ready_for_review, synchronize ]
  schedule:
    - cron: '0 17 * * 0'
  workflow_dispatch:

defaults:
  run:
    shell: bash

jobs:
  check:
    name: Check Upstream Status
    runs-on: ubuntu-22.04
    outputs:
      debug: ${{ steps.status.outputs.debug }}
      continue: ${{ steps.test.outputs.continue }}
      upstream: ${{ steps.test.outputs.upstream }}
      rids: ${{ steps.test.outputs.rids }}
      ridArray: ${{ steps.test.outputs.ridArray }}
      packagesUrl: ${{ steps.test.outputs.packagesUrl }}
      releasesUrl: ${{ steps.test.outputs.releasesUrl }}
      tagsUrl: ${{ steps.test.outputs.tagsUrl }}
      gitUrl: ${{ steps.test.outputs.gitUrl }}
      releasesNeeded: ${{ steps.test.outputs.releasesNeeded }}
    steps:
      - name: Debug Status
        if: github.event_name == 'pull_request'
        id: status
        run: |
          echo "debug=true" >> $GITHUB_OUTPUT

      - name: Check API
        id: test
        env:
          upstream: 'microsoft/msquic'
          rids: 'linux-x64 osx win-x64'
          ignoreReleases: 'v2.0.4'
          nupkgNamePrefix: 'StirlingLabs.MsQuic.Bindings.runtime.'
          nupkgNameSuffix: '.openssl'
        run: |
          # GitHub info
          releasesUrl="https://api.github.com/repos/${upstream}/releases"
          releasesJson=$(jq -c . <<< $(curl -s ${releasesUrl}))
          releaseArray=$(jq -r ".[].tag_name" <<< $releasesJson)
          echo "release list ${releaseArray}"
          # NuGet info
          declare -A packagesJson=()
          for rid in $rids ; do
            nupkgName="${nupkgNamePrefix}${rid}${nupkgNameSuffix}"
            packagesUrl="https://api.nuget.org/v3-flatcontainer/${nupkgName}/index.json"
            packageVersions[${rid//-/_}]=$(jq -c . <<< $(curl -s ${packagesUrl}))
          done
          #
          # Get a list of upstream releases that do not have all of the required packages
          continue="false"
          releasesNeeded=""
          space=""
          for release in ${releaseArray[@]} ; do
            # Skip exceptions due to upstream peculiarities (not in list and major version > 2)
            digits=${release:1}
            if [[ "$ignoreReleases" != *"$release"* ]] && [[ ${digits%%.*} -ge 2 ]] ; then
              # If the package is valid, consider it
              packageExists=""
              for rid in $rids ; do
                if [[ "$packageExists" != "false" ]] ; then
                  jq -r ".versions|sort|to_entries[]|(.value)" <<< ${packageVersions[${rid//-/_}]} | sort -V | grep "${digits}" && packageExists="true" || packageExists="false"
                fi
              done
              if [[ "$packageExists" == "false" ]] ; then
                continue="true"
                releasesNeeded="${releasesNeeded}${space}\"${release}\""
                space=", "
              fi
            fi
          done
          echo "upstream=$upstream" >> $GITHUB_OUTPUT
          echo "rids=$rids" >> $GITHUB_OUTPUT
          if [ "$continue" == "true" ] ; then
            ridArray="[ "
            ridArrayComma=""
            for rid in $rids ; do
              ridArray="${ridArray}${ridArrayComma}\"${rid}\""
              ridArrayComma=", "
            done
            ridArray="${ridArray} ]"
          fi
          echo "ridArray=$ridArray" >> $GITHUB_OUTPUT
          echo "continue=$continue" >> $GITHUB_OUTPUT
          echo "releases needed ${releasesNeeded}"
          echo "releasesNeeded=[ ${releasesNeeded} ]" >> $GITHUB_OUTPUT
          #
          # Make these URLs available for other scripts
          echo "releasesUrl=${releasesUrl}" >> $GITHUB_OUTPUT
          echo "tagsUrl=https://api.github.com/repos/${upstream}/tags" >> $GITHUB_OUTPUT
          echo "gitUrl=git://github.com/${upstream}.git" >> $GITHUB_OUTPUT

  binaries:
    name: Get Upstream Binaries
    needs: [ check ]
    if: needs.check.outputs.continue == 'true'
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        release: ${{ fromJson(needs.check.outputs.releasesNeeded) }}
    runs-on: ubuntu-22.04
    outputs:
      continue: ${{ steps.download.outputs.continue }}
      manifest: ${{ steps.download.outputs.manifest }}
      matrixRid: ${{ steps.download.outputs.ridArray }}
      readme: ${{ steps.ancillary.outputs.readme }}
      icon: ${{ steps.ancillary.outputs.icon }}
    steps:
      - name: Get Libraries
        id: download
        env:
          release: ${{ matrix.release }}
          releasesUrl: ${{ needs.check.outputs.releasesUrl }}
          tagsUrl: ${{ needs.check.outputs.tagsUrl }}
          rids: ${{ needs.check.outputs.rids }}
        run: |
          #
          # Get info about the release being processed
          echo "Processing $release"
          releaseJson=$(jq -r ".[] | select(.tag_name==\"${release}\")" <<< $(curl -s ${releasesUrl}))
          gitBranch=$(jq -r ".target_commitish" <<< $releaseJson)
          tagsJson=$(jq -c . <<< $(curl -s ${tagsUrl}))
          gitCommit=$(jq -r ".[] | select(.name==\"${release}\") | .commit.sha" <<< $tagsJson)
          #
          # Process this release
          continue="false"
          mkdir ${release}
          ridsAvailable="" && ridsAvailableComma=""
          for rid in $rids ; do
            echo " - $rid"
            v=${release:1}
            case "${rid}" in
              linux-x64)  platform="linux_x64" && upstreamFilename="libmsquic.so.$v" && ourFilename="libmsquic-openssl.so" ;;
              osx)        platform="macos_universal" && upstreamFilename="libmsquic.$v.dylib" && ourFilename="libmsquic-openssl.dylib" ;;
              win-x64)    platform="windows_x64" && upstreamFilename="msquic.dll" && ourFilename="msquic-openssl.dll" ;;
              *)          echo "Do not recognise ${os}." && exit 1 ;;
            esac
            archive="msquic_${platform}_Release_openssl.zip"
            url=$(jq -r ".assets | .[] | select(.name==\"${archive}\") | .browser_download_url" <<< $releaseJson)
            if [ "$url" != "" ] ; then
              echo "Downloading $url"
              wget --quiet ${url}
              unzip ${archive} -d ${platform}
              mkdir ${release}/${rid}
              finalFilename=${release}/${rid}/${ourFilename}
              mv ${platform}/bin/${upstreamFilename} ${finalFilename}
              sudo chmod +r ${finalFilename}
              rm -Rf ${platform} ${archive}
              ridsAvailable="${ridsAvailable}${ridsAvailableComma}{ \"rid\": \"${rid}\", \"location\": \"${finalFilename}\", \"filename\": \"${ours}\" }"
              ridsAvailableComma=",  "
            else
              echo "   - This release has no files for ${rid}."
            fi
          done

          if [ "$ridsAvailable" != "" ] ; then
            continue="true"
            manifest="{ \"version\": \"${release}\", \"gitBranch\": \"${gitBranch}\", \"gitCommit\": \"${gitCommit}\", \"platforms\": [ $ridsAvailable ] }"
          else
            continue=false
          fi
          #
          # Outputs
          echo "continue=${continue}" >> $GITHUB_OUTPUT
          echo "manifest=${manifest}" >> $GITHUB_OUTPUT

      - name: Upload Libraries
        if: steps.download.outputs.continue == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: Libraries-${{ matrix.release }}
          path: "./*"

      - name: Get Source
        if: steps.download.outputs.continue == 'true'
        uses: actions/checkout@v3
        with:
          submodules: true

      - name: Identify Ancillaries
        if: steps.download.outputs.continue == 'true'
        id: ancillary
        env:
          readme: StirlingLabs.MsQuic.Bindings/README.md
          icon: SL.png
          manifest: ${{ steps.download.outputs.manifest }}
        run: |
          if [[ -s "${readme}" ]] ; then
            echo "readme=${readme}" >> $GITHUB_OUTPUT
          else
            echo "README Not found at ${readme}"
          fi
          if [[ -s "${icon}" ]] ; then
            echo "icon=${icon}" >> $GITHUB_OUTPUT
          else
            echo "README Not found at ${icon}"
          fi
          echo $manifest > manifest.json
          find .

      - name: Upload Ancillaries
        if: steps.download.outputs.continue == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: Ancillaries-${{ matrix.release }}
          path: |
            ${{ steps.ancillary.outputs.readme }}
            ${{ steps.ancillary.outputs.icon }}
            manifest.json

  nupkg:
    name: Publish NuPkg
    needs: [ check, binaries ]
    if: |
      needs.check.outputs.continue == 'true' &&
      needs.binaries.outputs.continue == 'true'
    strategy:
      fail-fast: true
      max-parallel: 3
      matrix:
        version: ${{ fromJson(needs.check.outputs.releasesNeeded) }}
        rid: ${{ fromJson(needs.check.outputs.ridArray) }}
    runs-on: ubuntu-22.04
    steps:
      - name: Get Ancillaries
        id: ancillaries
        uses: actions/download-artifact@v3
        with:
          name: Ancillaries-${{ matrix.version }}

      - name: Data
        id: data
        env: 
          version: ${{ matrix.version }}
          rid: ${{ matrix.rid }}
          manifest: ${{steps.ancillaries.outputs.download-path}}/manifest.json
        run: |
          if [[ ! -s $manifest ]] ; then
            echo "Manifest does not exist"
            exit 1
          fi
          ridJson=$(jq -c ".platforms[] | select(.rid==\"${rid}\")" $manifest)
          if [[ "$ridJson" == "" ]] ; then
            echo "No manifest for $rid, so no need to continue."
            continue="false"
          else
            gitCommit=$(jq -r ".gitCommit" $manifest)
            gitBranch=$(jq -r ".gitBranch" $manifest)
            location=$(jq -r ".location" <<< $ridJson)
            filename=$(jq -r ".filename" <<< $ridJson)
            continue="true"
            echo "gitCommit ${gitCommit}, gitBranch ${gitBranch}, location ${location}, filename ${filename}"
          fi
          echo "continue=${continue}" >> $GITHUB_OUTPUT
          echo "gitCommit=${gitCommit}" >> $GITHUB_OUTPUT
          echo "gitBranch=${gitBranch}" >> $GITHUB_OUTPUT
          echo "location=${location}" >> $GITHUB_OUTPUT
          echo "filename=${filename}" >> $GITHUB_OUTPUT
          echo "ersion=${version:1}" >> $GITHUB_OUTPUT # remove the v
          echo "packageName=StirlingLabs.MsQuic.Bindings.runtime.${rid}.openssl" >> $GITHUB_OUTPUT

      - name: Get Libraries
        if: steps.data.outputs.continue == 'true'
        id: libraries
        uses: actions/download-artifact@v3
        with:
          name: Libraries-${{ matrix.version }}

      - name: Show File Context
        if: steps.data.outputs.continue == 'true'
        run: |
          find .

      - name: Create NuSpec
        if: steps.data.outputs.continue == 'true'
        id: nuspec
        uses: StirlingLabs/CreateNuSpecAction@main
        with:
          id: ${{ steps.data.outputs.packageName }}
          version: ${{ steps.data.outputs.ersion }}
          title: MsQuic runtime for ${{ matrix.rid }} ${{ matrix.version }}
          description: |
            Platform-specific runtime for MsQuic, Microsoft's C implementation of the IETF QUIC protocol.
          fileSources: ${{ steps.libraries.outputs.download-path }}/${{ steps.data.outputs.location }}
          fileTargets: runtimes/${{ matrix.rid }}/native/${{ steps.data.outputs.filename }}
          readme: ${{ steps.ancillaries.outputs.download-path }}/${{ needs.binaries.outputs.readme }}
          icon: ${{ steps.ancillaries.outputs.download-path }}/${{ needs.binaries.outputs.icon }}
          gitUrl: ${{ needs.check.outputs.gitUrl }}
          gitBranch: ${{ steps.data.outputs.gitBranch }}
          gitCommit: ${{ steps.data.outputs.gitCommit }}

      - name: Build NuPkg
        if: steps.data.outputs.continue == 'true'
        id: build
        env:
          nuspec: ${{ steps.nuspec.outputs.filename }}
        run: |
          nuget pack $nuspec
          [ $? -eq 0 ] && continue="true" || continue="false"
          echo "continue=${continue}" >> $GITHUB_OUTPUT
          ls -la

      - name: Push NuPkg to NuGet
        if: steps.build.outputs.continue == 'true'
        id: push
        env:
          debug: ${{ needs.check.outputs.debug }}
          githubKey: ${{ github.token }}
          githubUrl: "https://nuget.pkg.github.com/${{github.repository_owner}}/index.json"
          nugetKey: ${{ secrets.NUGET_STIRLINGLABS_API_KEY }}
          nugetUrl: "https://api.nuget.org/v3/index.json"
        run: |
          if [[ "$debug" == "true" ]] ; then
            key="$githubKey" && url="$githubUrl"
          else
            key="$nugetKey" && url="$nugetUrl"
          fi
          dotnet nuget push *.nupkg -k $key -s $url --no-symbols --skip-duplicate
          [ $? -eq 0 ] && continue="true" || continue="false"
          echo "continue=${continue}" >> $GITHUB_OUTPUT

      - name: Summary
        if: steps.push.outputs.continue == 'true'
        id: summary
        env:
          id: ${{ steps.data.outputs.packageName }}
          version: ${{ matrix.version }}
          rid: ${{ matrix.rid }}
        run: |
          echo "### Uploaded NuPkg for [${id}](https://www.nuget.org/packages/${id}) ${version} ${rid}." >> $GITHUB_STEP_SUMMARY

  code:
    name: Get Upstream Code
    needs: [ check ]
    if: needs.check.outputs.continue == 'true'
    runs-on: ubuntu-22.04
    steps:
      - name: Get Our Source
        uses: actions/checkout@v3
        with:
          submodules: true

      - name: Get Latest Code Archive
        id: retrieve
        env:
          upstream: ${{ needs.check.outputs.upstream }}
          import: 'src/cs/lib'
          target: 'StirlingLabs.MsQuic.Bindings'
        run: |
          base="${upstream}"
          latestJson=$(curl -s https://api.github.com/repos/${upstream}/releases/latest)
          version=$(jq -r ".tag_name" <<< $latestJson)
          url=$(jq -r ".zipball_url" <<< $latestJson)
          wget --quiet ${url} -O upstream.zip
          mkdir -p "${base}"
          unzip upstream.zip -d "${base}"
          rm -f upstream.zip
          subdir=$(ls ${base}) && subdirArray=( $subdir )
          if [[ "${#subdirArray[@]}" != "1" ]] ; then
            echo "${#subdirArray[@]} objects in $base ... $subdir"
            exit 1
          fi
          codebase="${base}/${subdir}"
          echo "base=${base}" >> $GITHUB_OUTPUT
          echo "source=${codebase}/${import}" >> $GITHUB_OUTPUT
          echo "target=${target}" >> $GITHUB_OUTPUT
          echo "version=${version}" >> $GITHUB_OUTPUT

      - name: Edit Upstream Files
        id: edit
        env:
          base: ${{ steps.retrieve.outputs.base }}
          source: ${{ steps.retrieve.outputs.source }}
          target: ${{ steps.retrieve.outputs.target }}/Imported
        run: |
          ls -la $source
          for entry in ${source}/*.cs ; do 
            if [[ "$entry" != *"InternalsVisible.cs" ]] ; then
              sed -i '1i \#nullable enable' "$entry"
              sed -i 's/\(^\s*\) \(\binternal\b\)/\1 public/' "$entry"
              sed -i 's/\bMicrosoft\.Quic\b/StirlingLabs.MsQuic.Bindings/' "$entry"
              sed -i 's/\(^.*DllImport.\{1,3\}\"msquic\)\(\"\)/\1-openssl\2/' "$entry"
              echo "Edited $entry"
              mv -f "$entry" ${target}/
            fi
          done
          rm -Rf "$base"
          ls -la $target

      - name: Update Our Files
        id: update
        env:
          target: ${{ steps.retrieve.outputs.target }}
          version: ${{ steps.retrieve.outputs.version }}
        run: |
          if [[ "${version:1}" == "" ]] ; then
            echo "Version not set, can't continue."
            exit 1
          fi
          file="${target}/${target}.csproj"
          sed -i "s/\(\bStirlingLabs\.MsQuic\.Bindings\.runtime\.\(linux\|osx\|win\).*\.openssl.*Version=\"\)\(.*\)\(\"\)/\1${version:1}\4/" "$file"
          echo "Edited $file"
          file="MsQuicVersionOnly.proj"
          echo "<Project><PropertyGroup><Version>${version:1}</Version></PropertyGroup></Project>" > $file
          echo "replaced $file"
          cat $file

      - name: Create PR
        uses: peter-evans/create-pull-request@v4
        with:
          commit-message: Update to incorporate upstream changes in {{ steps.retrieve.outputs.version }}
          base: main
          branch: upstream-${{ steps.retrieve.outputs.version }}
          delete-branch: true
          title: Update to ${{ steps.check.outputs.upstream }} ${{ steps.retrieve.outputs.version }}
          body: |
            Automatically prepared the following changes:
            - Re-imported upstream files and re-applied our modifications
            - Updated projects to refer to new upstream libraries

      - name: Summary
        id: summary
        env:
          version: ${{ steps.retrieve.outputs.version }}
        run: |
          echo "### Created PR for update to ${version}." >> $GITHUB_STEP_SUMMARY
